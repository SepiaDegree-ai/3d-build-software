"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectLongTrace = exports.UncoveredError = void 0;
exports.ensureError = ensureError;
exports.throwUncoveredError = throwUncoveredError;
exports.createUncoveredError = createUncoveredError;
class UnexpectedErrorStructureError extends Error {
}
/**
 * In JS catch clauses can receive not only Errors, but pretty much any other kind of data type, so
 * you can use this helper to ensure that whatever is passed in is a real error
 */
function ensureError(e, fallbackMessage) {
    if (e instanceof Error)
        return e;
    let stringifiedError = '';
    if (e !== null && e !== undefined) {
        try {
            stringifiedError = JSON.stringify(e);
        }
        catch {
            //ignore
        }
    }
    return new UnexpectedErrorStructureError(`${fallbackMessage}${stringifiedError !== '' ? `. Cause: ${stringifiedError}` : ''}`);
}
// this makes sure that a case is breaking in typing and in runtime too
function throwUncoveredError(e) {
    throw createUncoveredError(e);
}
class UncoveredError extends Error {
}
exports.UncoveredError = UncoveredError;
function createUncoveredError(e) {
    return new UncoveredError(`Uncovered error case ${e}.`);
}
/**
 * Note: Only V8 and Node.js support controlling the stack trace limit
 */
const collectLongTrace = (limit) => {
    const originalLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = limit || 30;
    const trace = (new Error().stack || '').split('\n').slice(1).join('\n').trim();
    Error.stackTraceLimit = originalLimit;
    return trace;
};
exports.collectLongTrace = collectLongTrace;
//# sourceMappingURL=error.js.map