"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLogger = getLogger;
exports.extendLoggerComponent = extendLoggerComponent;
exports.simpleRpmCounter = simpleRpmCounter;
const pino_1 = require("pino");
const pinoClef_js_1 = require("./pinoClef.js");
let logger;
const defaultLevelFormatterFactory = (pretty) => (label, number) => 
// for not pretty, we're providing clef levels
pretty ? { level: label } : (0, pinoClef_js_1.toClefLogLevel)(number);
const defaultLogFormatterFactory = (pretty) => (logObject) => pretty ? logObject : (0, pinoClef_js_1.toClef)(logObject);
function getLogger(minimumLoggedLevel = 'info', pretty = false, mixin) {
    if (logger)
        return logger;
    const pinoOptions = {
        base: undefined, // Set to undefined to avoid adding pid, hostname properties to each log.
        formatters: {
            level: defaultLevelFormatterFactory(pretty),
            log: defaultLogFormatterFactory(pretty)
        },
        mixin,
        // when not pretty, to produce a clef format, we need the message to be the message template key
        messageKey: pretty ? 'msg' : '@mt',
        level: minimumLoggedLevel,
        // when not pretty, we need the time in the clef appropriate field, not from pino
        timestamp: pretty ? pino_1.pino.stdTimeFunctions.isoTime : false
    };
    if (pretty) {
        pinoOptions.transport = {
            target: '@speckle/shared/pinoPrettyTransport.cjs',
            options: {
                colorize: true,
                destination: 2, //stderr
                ignore: 'time',
                levelFirst: true,
                singleLine: true
            }
        };
    }
    logger = (0, pino_1.pino)(pinoOptions);
    return logger;
}
function extendLoggerComponent(otherChild, ...subComponent) {
    const otherChildBindings = otherChild.bindings();
    otherChildBindings.component = [otherChildBindings.component, ...subComponent]
        .filter(Boolean)
        .join('/');
    return otherChild.child(otherChildBindings);
}
/**
 * Very simple RPM counter to catch extreme spam scenarios (e.g. a ton of errors being thrown). It's not going
 * to always report accurately, but as long as hits are being registered consistently it should be accurate enough.
 */
function simpleRpmCounter() {
    const getTimestamp = () => new Date().getTime();
    let lastDateTimestamp = getTimestamp();
    let hits = 0;
    const validateHits = () => {
        const timestamp = getTimestamp();
        if (timestamp > lastDateTimestamp + 60 * 1000) {
            hits = 0;
            lastDateTimestamp = timestamp;
        }
    };
    return {
        hit: () => {
            validateHits();
            return ++hits;
        },
        get: () => {
            validateHits();
            return hits;
        }
    };
}
//# sourceMappingURL=index.js.map