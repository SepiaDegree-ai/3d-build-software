export declare const specklePointVert = "\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef USE_RTE\n    // The high component is stored as the default 'position' attribute buffer\n    attribute vec3 position_low;\n    uniform vec3 uViewer_high;\n    uniform vec3 uViewer_low;\n#endif\n\nhighp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){\n    /* \n    Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl \n    Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy \n    */\n    highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;\n    highp vec3 e = t1 - position_low.xyz;\n    /** This is redunant, but necessary as a workaround for Apple platforms */\n    highp float x = position_high.x - relativeTo_high.x;\n    highp float y = position_high.y - relativeTo_high.y;\n    highp float z = position_high.z - relativeTo_high.z;\n    highp vec3 v = vec3(x, y, z);\n    /** End of redundant part */\n    highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;\n    highp vec3 highDifference = t1 + t2;\n    highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);\n    \n    highp vec3 position = highDifference.xyz + lowDifference.xyz;\n    return vec4(position, 1.);\n}\n\n#ifdef USE_GRADIENT_RAMP\n    attribute float gradientIndex;\n    varying float vGradientIndex;\n#endif\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t// #include <project_vertex> COMMENTED CHUNK\n\t#ifdef USE_RTE\n        vec4 mvPosition = computeRelativePosition(position_low.xyz, position.xyz, uViewer_low, uViewer_high);\n    #else\n        vec4 mvPosition = vec4( transformed, 1.0 );\n    #endif\n    \n    #ifdef USE_INSTANCING\n\n        mvPosition = instanceMatrix * mvPosition;\n\n    #endif\n    mvPosition = modelViewMatrix * mvPosition;\n\n    #ifdef USE_GRADIENT_RAMP\n        vGradientIndex = gradientIndex;\n    #endif\n\n    gl_Position = projectionMatrix * mvPosition;\n\n\tgl_PointSize = size;\n\n\t#ifdef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n\n}\n";
